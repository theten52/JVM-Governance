# 8 并发标记清除（CMS）收集器

并发标记清除（CMS）收集器是为那些希望垃圾回收暂停时间更短，并且在应用程序运行时能够允许与垃圾收集器共享处理器资源的应用程序而设计的。通常，那些拥有相对大量长生命周期数据（大的老年代）且运行在具有两个或更多处理器的机器上的应用程序往往能从使用此收集器中受益。不过，任何有低暂停时间要求的应用程序都可以考虑使用这个收集器。可以使用命令行选项 `-XX:+UseConcMarkSweepGC` 来启用 CMS 收集器。

与其他可用的收集器类似，CMS 收集器是分代式的；因此会同时发生 Minor 收集和 Major 收集。CMS 收集器尝试通过使用单独的垃圾回收线程与应用程序线程并发地跟踪可达对象，来减少因 Major 收集而导致的停顿时间。在每个 Major 收集周期中，CMS 收集器会在收集开始时短暂暂停所有应用程序线程，并在收集进行到中途时再次暂停。第二次暂停往往比第一次暂停时间更长。在这两次暂停期间，会使用多个线程来执行收集工作。收集的其余部分（包括对存活对象的大部分跟踪和对不可达对象的清理）由一个或多个与应用程序并发运行的垃圾回收线程完成。Minor 收集可以与正在进行的 Major 收集周期交错进行，并且其执行方式与并行收集器类似（特别是在 Minor 收集期间，应用程序线程会被停止）。

## 并发模式失败

CMS 收集器使用一个或多个垃圾回收线程，这些线程与应用程序线程同时运行，其目标是在老年代满之前完成老年代的垃圾回收。如前所述，在正常操作中，CMS 收集器在应用程序线程仍在运行的情况下完成大部分的标记和清除工作，因此应用程序线程只会经历短暂的停顿。然而，如果 CMS 收集器在老年代填满之前无法完成对不可达对象的回收，或者如果老年代中可用的空闲空间块无法满足内存分配需求，那么应用程序将被暂停，并且在所有应用程序线程停止的情况下完成垃圾回收。无法并发完成垃圾回收被称为并发模式失败，这表明需要调整 CMS 收集器的参数。如果并发垃圾回收被显式的垃圾回收（ `System.gc()` ）中断，或者为了向诊断工具提供信息而需要进行垃圾回收，那么将报告并发模式中断。



## 过多的垃圾回收（GC）时间和内存溢出错误

如果在垃圾回收上花费的时间过多，CMS 收集器会抛出一个 `OutOfMemoryError` ：如果总时间的 98%以上都花在了垃圾回收上，而堆内存的回收率低于 2%，那么就会抛出一个 `OutOfMemoryError` 。此功能旨在防止应用程序由于堆内存过小而长时间运行却几乎没有进展。如有必要，可以通过在命令行中添加选项 `-XX:-UseGCOverheadLimit` 来禁用此功能。

该策略与并行收集器中的策略相同，不同之处在于执行并发收集所花费的时间不计入 98% 的时间限制内。换句话说，只有在应用程序停止时执行的收集才会计入过长的垃圾回收（GC）时间。此类收集通常是由于并发模式失败或显式的收集请求（例如，调用 `System.gc` ）导致的。





## 漂浮垃圾

CMS 收集器和 Java HotSpot 虚拟机中的所有其他收集器一样，是一种追踪式收集器，它至少能识别堆中所有可达对象。用理查德·琼斯（Richard Jones）和拉斐尔·D·林斯（Rafael D. Lins）在其著作《垃圾回收：自动动态内存算法》（Garbage Collection: Algorithms for Automated Dynamic Memory）中的说法，它是一种增量更新收集器。由于在一次大回收期间应用程序线程和垃圾收集器线程会并发运行，因此在垃圾收集器线程追踪对象之后，到收集过程结束时这些对象可能会变得不可达。这些尚未被回收的不可达对象被称为浮动垃圾。浮动垃圾的数量取决于并发收集周期的持续时间以及应用程序进行引用更新（也称为变异）的频率。此外，由于新生代和老年代是独立进行回收的，因此它们互为根对象的来源。作为一个大致的指导原则，可以尝试将老年代的大小增加 20%以应对浮动垃圾。 在一个并发收集周期结束时堆中的浮动垃圾会在下一个收集周期中被收集。





## 暂停；停顿；间歇（这里“Pauses”是“pause”的第三人称单数和复数形式，根据语境可能有不同含义，这里给出常见释义）

在并发收集周期中，CMS 收集器会让应用程序暂停两次。第一次暂停是为了标记那些从根对象（例如，应用程序线程栈和寄存器中的对象引用、静态对象等）以及堆的其他位置（例如，新生代）可直接访问的存活对象。这第一次暂停被称为初始标记暂停。第二次暂停发生在并发跟踪阶段结束时，用于找出那些由于在 CMS 收集器完成对某个对象的跟踪后，应用程序线程更新了该对象中的引用而被并发跟踪遗漏的对象。这第二次暂停被称为重新标记暂停。





## 并发阶段

可达对象图的并发跟踪发生在初始标记暂停和重新标记暂停之间。在这个并发跟踪阶段，一个或多个并发垃圾回收器线程可能会占用原本可供应用程序使用的处理器资源。因此，即使应用程序线程没有暂停，计算密集型应用程序在这个阶段以及其他并发阶段的应用程序吞吐量也可能会相应下降。重新标记暂停之后，并发清除阶段会回收那些被标记为不可达的对象。一旦一个回收周期完成，CMS 收集器就会进入等待状态，几乎不消耗计算资源，直到下一个主要回收周期开始。





## 启动并发收集周期

使用串行收集器时，只要老年代空间已满，就会进行一次大的垃圾收集，并且在收集过程中所有应用线程都会停止。相比之下，并发收集的启动时机必须经过精心安排，要确保收集工作能在老年代空间满之前完成；否则，由于并发模式失败，应用程序会出现更长时间的停顿。有几种方法可以启动并发收集。

根据近期情况，CMS 收集器会维护关于老年代即将耗尽前剩余时间以及一次并发收集周期所需时间的估算值。利用这些动态估算值，会启动一次并发收集周期，目的是在老年代耗尽之前完成收集周期。为了安全起见，这些估算值会有一定的余量，因为并发模式失败的代价可能非常高。

如果老年代的占用率超过了初始占用率（老年代的一个百分比），并发收集也会启动。此初始占用率阈值的默认值约为 92%，但该值可能会因版本而异。可以使用命令行选项 `-XX:CMSInitiatingOccupancyFraction=<N>` 手动调整此值，其中 `<N>` 是老年代大小的一个整数百分比（0 到 100）。





## 调度暂停

年轻代收集的停顿和老年代收集的停顿是独立发生的。它们不会重叠，但可能会快速连续出现，以至于一次收集的停顿紧接着另一次收集的停顿，看起来就像是一次更长的单一停顿。为避免这种情况，CMS 收集器会尝试将重标记停顿安排在前一次和下一次年轻代停顿的大致中间位置。目前，初始标记停顿不会进行这样的调度，因为它通常比重标记停顿短得多。



## 增量模式

请注意，增量模式在 Java SE 8 中已被弃用，可能会在未来的主要版本中移除。

CMS 收集器可以在一种模式下使用，在该模式中并发阶段会以增量方式执行。回想一下，在并发阶段，垃圾回收器线程会使用一个或多个处理器。增量模式旨在通过定期停止并发阶段，将处理器交还给应用程序，来减轻长时间并发阶段的影响。此模式在这里称为 i - cms，它将收集器并发执行的工作划分为小的时间段，并安排在新生代收集之间执行。当需要 CMS 收集器提供的低暂停时间的应用程序在处理器数量较少（例如 1 个或 2 个）的机器上运行时，此功能非常有用。

并发收集周期通常包括以下步骤：

- 停止所有应用程序线程，识别从根对象可达的对象集，然后恢复所有应用程序线程。
- 在应用程序线程执行的同时，使用一个或多个处理器并发跟踪可达对象图。
- 使用一个处理器同时回溯自上一步跟踪以来被修改的对象图部分。
- 停止所有应用程序线程，并回溯自上次检查以来可能已被修改的根对象和对象图的部分，然后恢复所有应用程序线程。
- 同时使用一个处理器将不可达对象清理到用于分配的空闲列表中。
- 使用一个处理器同时调整堆的大小，并为下一个收集周期准备支持数据结构。

通常情况下，CMS 收集器在整个并发标记阶段会使用一个或多个处理器，并且不会主动释放它们。同样，在整个并发清除阶段也会使用一个处理器，同样不会释放它。对于有响应时间限制、原本可能会使用这些处理核心的应用程序来说，这种开销可能会造成过大的干扰，尤其是在只有一两个处理器的系统上运行时。增量模式通过将并发阶段拆分成短时间的活动片段来解决这个问题，这些活动片段被安排在 Minor 停顿的中间时段执行。

i-cms 模式使用占空比来控制 CMS 收集器在自愿放弃处理器之前被允许执行的工作量。占空比是指在新生代收集之间，CMS 收集器被允许运行的时间百分比。i-cms 模式可以根据应用程序的行为自动计算占空比（这是推荐的方法，称为自动调节），也可以在命令行上将占空比设置为固定值。



命令行选项

表 8 - 1“i - cms 的命令行选项”列出了控制 i - cms 模式的命令行选项。“推荐选项”部分给出了一组初始选项建议。



表 8 - 1 i - cms 的命令行选项

| 选项                                   | 描述                                                         | 默认值，Java SE 5 及更早版本 | 默认值，Java SE 6 及更高版本 |
| -------------------------------------- | ------------------------------------------------------------ | ---------------------------- | ---------------------------- |
| `-XX:+CMSIncrementalMode`              | 启用增量模式。请注意，要使此选项生效，还必须启用 CMS 收集器（使用 `-XX:+UseConcMarkSweepGC` ）。 | 禁用的；不可用的；有残疾的   | 禁用的；不可用的；有残疾的   |
| `-XX:+CMSIncrementalPacing`            | 启用自动调速功能。增量模式占空比会根据 JVM 运行时收集的统计信息自动调整。 | 禁用的；失效的；有残疾的     | 禁用的；不可用的；有残疾的   |
| `-XX:CMSIncrementalDutyCycle=<N>`    | CMS 收集器在次要收集之间允许运行的时间百分比（0 到 100）。如果启用了 `CMSIncrementalPacing` ，则这只是初始值。 | 50                           | 10                           |
| `-XX:CMSIncrementalDutyCycleMin=<N>` | 当 `CMSIncrementalPacing` 启用时，占空比下限的百分比（0 到 100）。 | 10                           | 0                            |
| `-XX:CMSIncrementalSafetyFactor=<N>` | 计算占空比时用于增加保守性的百分比（0 到 100）               | 10                           | 10                           |
| `-XX:CMSIncrementalOffset=<N>`       | 在小回收间隔期间，增量模式占空比向右偏移的百分比（0 到 100）。 | 0                            | 0                            |
| `-XX:CMSExpAvgFactor=<N>`            | 在为 CMS 收集统计信息计算指数平均值时，用于对当前样本进行加权的百分比（0 到 100）。 | 25                           | 25                           |





### 推荐选项

要在 Java SE 8 中使用 i-cms，请使用以下命令行选项：

`
-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode \
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps
`

前两个选项分别启用 CMS 收集器和 i-cms。最后两个选项不是必需的；它们只是将有关垃圾回收的诊断信息写入标准输出，以便可以查看并在以后分析垃圾回收行为。

对于 Java SE 5 及更早版本，Oracle 建议将以下内容作为 i-cms 的初始命令行选项集：

`
-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode \
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps \
-XX:+CMSIncrementalPacing -XX:CMSIncrementalDutyCycleMin=0
-XX:CMSIncrementalDutyCycle=10
`

虽然控制 i - cms 自动节奏的三个选项的值在 JavaSE6 中已成为默认值，但对于 JavaSE8 也建议使用相同的值。



基本故障排除

i-cms 自动调步功能会利用程序运行期间收集的统计信息来计算占空比，以便在堆空间填满之前完成并发收集。然而，过去的行为并不能完美预测未来的行为，这些估算值可能并不总是足够准确，从而无法防止堆空间被填满。如果发生了过多的全量收集，请依次尝试表 8 - 2“排查 i-cms 自动调步功能问题”中的步骤。



表 8 - 2 排查 i - cms 自动起搏功能问题

| 步骤                                  | 选项                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| 1. 提高安全系数。                     | `-XX:CMSIncrementalSafetyFactor=<N>`                       |
| 2. 增加最小占空比。                   | `-XX:CMSIncrementalDutyCycleMin=<N>`                       |
| 3. 禁用自动调速功能，使用固定占空比。 | `-XX:-CMSIncrementalPacing -XX:CMSIncrementalDutyCycle=<N>` |









测量；测量值；尺寸；规模

示例 8 - 1，“CMS 收集器的输出”是使用选项 `-verbose:gc` 和 `-XX:+PrintGCDetails` 时 CMS 收集器的输出，其中去除了一些细微的细节。请注意，CMS 收集器的输出与小对象收集的输出穿插在一起；通常在一次并发收集周期中会发生多次小对象收集。CMS-initial-mark 表示并发收集周期的开始，CMS-concurrent-mark 表示并发标记阶段的结束，而 CMS-concurrent-sweep 标记并发清除阶段的结束。之前未讨论过的是由 CMS-concurrent-preclean 表示的预清理阶段。预清理代表可以并发完成的、为重新标记阶段 CMS-remark 做准备的工作。最后一个阶段由 CMS-concurrent-reset 表示，是为下一次并发收集做准备。

示例 8 - 1：内容管理系统（CMS）收集器的输出

`
[GC [1 CMS-initial-mark: 13991K(20288K)] 14103K(22400K), 0.0023781 secs]
[GC [DefNew: 2112K->64K(2112K), 0.0837052 secs] 16103K->15476K(22400K), 0.0838519 secs]
...
[GC [DefNew: 2077K->63K(2112K), 0.0126205 secs] 17552K->15855K(22400K), 0.0127482 secs]
[CMS-concurrent-mark: 0.267/0.374 secs]
[GC [DefNew: 2111K->64K(2112K), 0.0190851 secs] 17903K->16154K(22400K), 0.0191903 secs]
[CMS-concurrent-preclean: 0.044/0.064 secs]
[GC [1 CMS-remark: 16090K(20288K)] 17242K(22400K), 0.0210460 secs]
[GC [DefNew: 2112K->63K(2112K), 0.0716116 secs] 18177K->17382K(22400K), 0.0718204 secs]
[GC [DefNew: 2111K->63K(2112K), 0.0830392 secs] 19363K->18757K(22400K), 0.0832943 secs]
...
[GC [DefNew: 2111K->0K(2112K), 0.0035190 secs] 17527K->15479K(22400K), 0.0036052 secs]
[CMS-concurrent-sweep: 0.291/0.662 secs]
[GC [DefNew: 2048K->0K(2112K), 0.0013347 secs] 17527K->15479K(27912K), 0.0014231 secs]
[CMS-concurrent-reset: 0.016/0.016 secs]
[GC [DefNew: 2048K->1K(2112K), 0.0013936 secs] 17527K->15479K(27912K), 0.0014814 secs
]
`



初始标记暂停相对于小对象收集暂停时间通常较短。并发阶段（并发标记、并发预清理和并发清除）通常比小对象收集暂停持续的时间长得多，如示例 8 - 1“CMS 收集器的输出”所示。不过要注意，在这些并发阶段应用程序不会暂停。重标记暂停的时长通常与小对象收集暂停相当。重标记暂停会受到某些应用程序特性（例如，较高的对象修改率可能会增加此暂停时间）以及自上次小对象收集以来的时间（例如，新生代中有更多对象可能会增加此暂停时间）的影响。