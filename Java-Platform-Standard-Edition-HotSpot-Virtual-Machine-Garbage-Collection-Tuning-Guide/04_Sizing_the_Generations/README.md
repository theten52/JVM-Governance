#  4 评估各代人的规模

许多参数会影响生成空间的大小。图 4 - 1“堆参数”展示了堆中已提交空间和虚拟空间的区别。在虚拟机初始化时，会为堆预留整个空间。预留空间的大小可以通过 `-Xmx` 选项指定。如果 `-Xms` 参数的值小于 `-Xmx` 参数的值，那么预留的空间不会全部立即提交给虚拟机。在该图中，未提交的空间标记为“虚拟”。堆的不同部分（老年代和新生代）可以根据需要增长到虚拟空间的上限。

一些参数是堆的一部分与另一部分的比率。例如，参数 `NewRatio` 表示老年代与新生代的相对大小。

***图 4 - 1 堆参数\***

![Description of Figure 4-1 follows](./assets/README/jsgct_dt_006_prm_gn_sz.png)

[“图 4 - 1 堆参数”说明](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img_text/jsgct_dt_006_prm_gn_sz.html)



 总堆

以下关于堆的增长和收缩以及默认堆大小的讨论不适用于并行收集器。（有关并行收集器的堆大小调整和默认堆大小的详细信息，请参阅《各代大小调整》中的“并行收集器自动调优”部分。）但是，控制堆总大小和各代大小的参数确实适用于并行收集器。

影响垃圾回收性能的最重要因素是总可用内存。由于当各代内存填满时就会进行回收，因此吞吐量与可用内存量成反比。

默认情况下，虚拟机在每次垃圾回收时会调整堆的大小，试图将每次回收时空闲空间与存活对象的比例保持在特定范围内。此目标范围由参数 `-XX:MinHeapFreeRatio=` `<minimum>` 和 `-XX:MaxHeapFreeRatio=` `<maximum>` 以百分比形式设置，总大小下限为 `-Xms` `<min>` ，上限为 `-Xmx` `<max>` 。64 位 Solaris 操作系统（SPARC 平台版）的默认参数如表 4 - 1“64 位 Solaris 操作系统的默认参数”所示：



表 4 - 1 64 位 Solaris 操作系统的默认参数

| 参数               | 默认值       |
| ------------------ | ------------ |
| `MinHeapFreeRatio` | `40`         |
| `MaxHeapFreeRatio` | `70`         |
| `-Xms`             | `6656k`      |
| `-Xmx`             | `calculated` |

使用这些参数，如果某一代的空闲空间百分比降至 40% 以下，那么这一代将被扩展以维持 40% 的空闲空间，直至达到该代允许的最大大小。同样地，如果空闲空间超过 70%，那么这一代将被收缩，以便只有 70% 的空间处于空闲状态，但需满足该代的最小大小要求。

如“表 4 - 1：64 位 Solaris 操作系统的默认参数”所示，默认最大堆大小是一个由 JVM 计算得出的值。Java SE 中用于并行收集器和服务器 JVM 的计算方法现在适用于所有垃圾收集器。该计算的一部分是对最大堆大小设置上限，此上限在 32 位平台和 64 位平台上有所不同。请参阅《并行收集器》中的“默认堆大小”部分。客户端 JVM 也有类似的计算，其得出的最大堆大小比服务器 JVM 的要小。

以下是关于服务器应用程序堆大小的一般准则：

- 除非你在处理暂停方面存在问题，否则请尝试为虚拟机分配尽可能多的内存。默认大小通常过小。
- 将 `-Xms` 和 `-Xmx` 设置为相同的值，通过从虚拟机中移除最重要的大小调整决策来提高可预测性。然而，如果您做出了糟糕的选择，虚拟机将无法进行补偿。
- 一般来说，随着处理器数量的增加，要相应增加内存，因为内存分配可以并行进行。

##  年轻一代

在总可用内存之后，影响垃圾回收性能的第二大因素是堆中分配给新生代的比例。新生代越大，小垃圾回收发生的频率就越低。然而，对于固定大小的堆，更大的新生代意味着更小的老年代，这将增加大垃圾回收的频率。最佳选择取决于应用程序所分配对象的生命周期分布。

默认情况下，新生代的大小由参数 `NewRatio` 控制。例如，设置 `-XX:NewRatio=3` 意味着新生代与老年代的比例为 1:3。换句话说，Eden 区和幸存者区的总大小将是堆总大小的四分之一。

参数 `NewSize` 和 `MaxNewSize` 分别从下限和上限界定了新生代的大小。将这两个参数设置为相同的值可以固定新生代的大小，就像将 `-Xms` 和 `-Xmx` 设置为相同的值可以固定堆的总大小一样。这对于以比 `NewRatio` 所允许的整数倍更精细的粒度来调优新生代很有用。



###  幸存者空间大小设定

你可以使用参数 `SurvivorRatio` 来调整幸存者空间的大小，但这通常对性能影响不大。例如， `-XX:SurvivorRatio=6` 将 eden 空间与一个幸存者空间的比例设置为 1:6。换句话说，每个幸存者空间的大小将是 eden 空间的六分之一，因此是新生代空间的八分之一（不是七分之一，因为有两个幸存者空间）。

如果幸存者空间太小，复制收集会直接溢出到老年代。如果幸存者空间太大，它们就会白白空置。在每次垃圾回收时，虚拟机都会选择一个阈值，即对象在进入老年代之前可以被复制的次数。选择这个阈值是为了让幸存者空间保持半满状态。命令行选项 `-XX:+PrintTenuringDistribution` （并非所有垃圾回收器都支持）可用于显示这个阈值以及新生代中对象的年龄。它对于观察应用程序的生命周期分布也很有用。

表 4 - 2“幸存者空间大小的默认参数值”提供了 64 位 Solaris 的默认值：



表 4 - 2 幸存者空间大小的默认参数值

| 参数            | 服务器 JVM 默认值 |
| --------------- | ----------------- |
| `NewRatio`      | `2`               |
| `NewSize`       | `1310M`           |
| `MaxNewSize`    | 不受限制          |
| `SurvivorRatio` | `8`               |

新生代的最大大小将根据堆的总最大大小和 `NewRatio` 参数的值来计算。 `MaxNewSize` 参数的默认值 “无限制” 意味着，除非在命令行中指定了 `MaxNewSize` 的值，否则计算出的值不受 `MaxNewSize` 的限制。

以下是服务器应用程序的一般准则：

- 首先确定你能为虚拟机分配的最大堆大小。然后将性能指标与新生代大小进行对比绘图，以找到最佳设置。
  - 请注意，最大堆大小应始终小于机器上安装的内存量，以避免出现过多的页面错误和内存抖动。
- 如果堆的总大小是固定的，那么增大新生代的大小就需要减小老年代的大小。要保证老年代足够大，以便能容纳应用程序在任何给定时刻所使用的所有存活数据，再加上一定的空闲空间（10% 到 20% 或更多）。
- 受先前所述的终身教职一代的限制条件约束：
  - 为新生代分配大量内存。
  - 随着处理器数量的增加，增大年轻代的大小，因为内存分配可以并行进行。