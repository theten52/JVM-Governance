#  5 可用的收集器

到目前为止，讨论的内容一直围绕串行收集器展开。Java HotSpot 虚拟机包含三种不同类型的收集器，每种都有不同的性能特征。

- 串行收集器使用单线程来执行所有垃圾回收工作，这使其效率相对较高，因为线程之间不存在通信开销。它最适合单处理器机器，因为它无法利用多处理器硬件的优势，不过对于数据集较小（最多约 100 MB）的应用程序，在多处理器上使用它也可能会有效果。在某些硬件和操作系统配置中，串行收集器是默认选择，也可以通过选项 `-XX:+UseSerialGC` 显式启用。

- 并行收集器（也称为吞吐量收集器）会并行执行次要垃圾回收（Minor GC），这可以显著减少垃圾回收开销。它适用于在多处理器或多线程硬件上运行的、具有中大型数据集的应用程序。在某些硬件和操作系统配置中，并行收集器会默认启用，也可以通过选项 `-XX:+UseParallelGC` 显式启用。

  - 并行压缩是一项功能，它使并行收集器能够并行执行大对象收集。如果没有并行压缩，大对象收集将使用单线程执行，这可能会显著限制可扩展性。如果指定了选项 `-XX:+UseParallelGC` ，则默认启用并行压缩。关闭该功能的选项是 `-XX:-UseParallelOldGC` 。

- 主要并发收集器（The mostly concurrent collector）会并发地执行其大部分工作（例如，在应用程序仍在运行时），以保持垃圾回收暂停时间较短。它专为处理中大型数据集的应用程序而设计，在这些应用程序中，响应时间比整体吞吐量更重要，因为用于减少暂停的技术可能会降低应用程序性能。Java HotSpot 虚拟机提供了两种主要并发收集器（The mostly concurrent collector）供选择；请参阅“主要并发收集器（The mostly concurrent collector）”。使用选项 `-XX:+UseConcMarkSweepGC` 来启用 CMS 收集器，或使用选项 `-XX:+UseG1GC` 来启用 G1 收集器。

##  选择一个收集器

除非你的应用程序对暂停时间有相当严格的要求，否则应先运行你的应用程序，让虚拟机选择一个垃圾收集器。如有必要，调整堆大小以提高性能。如果性能仍然无法达到你的目标，那么可以将以下准则作为选择垃圾收集器的起点。

- 如果应用程序的数据集较小（最多约 100 MB），那么使用选项 `-XX:+UseSerialGC` 选择串行收集器。

- 如果应用程序将在单处理器上运行，并且没有暂停时间要求，那么让虚拟机选择垃圾收集器，或者使用选项 `-XX:+UseSerialGC` 选择串行收集器。

- 如果 (a) 应用程序的峰值性能是首要任务，并且 (b) 没有暂停时间要求，或者可以接受 1 秒或更长时间的暂停，那么让虚拟机选择垃圾收集器，或者使用 `-XX:+UseParallelGC` 选择并行收集器。

- 如果响应时间比整体吞吐量更重要，并且垃圾回收暂停时间必须保持在大约 1 秒以内，那么选择带有 `-XX:+UseConcMarkSweepGC` 或 `-XX:+UseG1GC` 的并发收集器。

这些指南仅为选择收集器提供了一个起点，因为性能取决于堆的大小、应用程序维护的存活数据量以及可用处理器的数量和速度。暂停时间对这些因素尤为敏感，因此前面提到的 1 秒阈值只是近似值：在许多数据大小和硬件组合的情况下，并行收集器的暂停时间会超过 1 秒；相反，在某些组合下，并发收集器可能无法将暂停时间控制在 1 秒以内。

如果推荐的收集器未能达到预期性能，首先尝试调整堆和代的大小以实现预期目标。如果性能仍然不足，则尝试使用不同的收集器：使用并发收集器来减少停顿时间，使用并行收集器来提高多处理器硬件的整体吞吐量。