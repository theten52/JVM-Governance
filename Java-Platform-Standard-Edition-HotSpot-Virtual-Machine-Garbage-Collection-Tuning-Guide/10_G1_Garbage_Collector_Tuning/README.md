# 10 垃圾优先垃圾回收器调优

本节介绍如何针对评估、分析和性能对 G1 垃圾回收器（G1 GC）进行调整和调优。

如“Garbage-First 垃圾收集器”部分所述，G1 垃圾收集器是一种分区域的、分代的垃圾收集器，这意味着 Java 对象堆（堆）被划分为多个大小相等的区域。Java 虚拟机（JVM）在启动时会设置区域大小。区域大小可根据堆大小在 1MB 到 32MB 之间变化。目标是区域数量不超过 2048 个。Eden 区、幸存者区（Survivor区）和老年代是这些区域的逻辑集合，它们并不连续。

G1 垃圾回收器有一个它试图达成的停顿时间目标（软实时）。在新生代垃圾回收期间，G1 垃圾回收器会调整其新生代（Eden 区和幸存者区（Survivor区）大小）以满足软实时目标。有关 G1 垃圾回收器为何会产生停顿以及如何设置停顿时间目标的信息，请参阅《G1 垃圾回收器》中的“停顿”和“停顿时间目标”部分。

在混合收集期间，G1 垃圾回收器会根据混合垃圾回收的目标次数、堆中每个区域的存活对象百分比以及总体可接受的堆空间浪费百分比，来调整要收集的老年代区域数量。

G1 垃圾收集器（G1 GC）通过将存活对象从一个或多个区域集合（称为收集集（CSet））增量式并行复制到一个或多个不同的新区域来减少堆碎片化，以实现堆内存的紧凑。其目标是尽可能多地回收堆空间，从包含最多可回收空间的区域开始，同时尽量不超过停顿时间目标（优先处理垃圾）。

G1 垃圾回收器（G1 GC）使用独立的记忆集（RSets）来跟踪指向区域的引用。独立的记忆集支持对区域进行并行且独立的回收，因为只需扫描某个区域的记忆集来查找指向该区域的引用，而无需扫描整个堆。G1 垃圾回收器使用写后屏障来记录堆的变化并更新记忆集。

垃圾回收阶段

除了构成“停止世界”（STW）新生代和混合垃圾回收的疏散暂停（请参阅“G1 垃圾回收器中的分配（疏散）失败”部分）之外，G1 垃圾回收器（G1 GC）还有并行、并发和多阶段的标记周期。G1 GC 使用起始快照（SATB）算法，该算法在标记周期开始时逻辑上对堆中存活对象集进行一次快照。存活对象集还包括自标记周期开始以来分配的对象。G1 GC 标记算法使用写前屏障来记录和标记属于逻辑快照一部分的对象。

## 新生代垃圾回收

G1 垃圾回收器（G1 GC）会满足大多数来自添加到 Eden 区域集中的区域的分配请求。在一次新生代垃圾回收期间，G1 GC 会回收 Eden 区域以及上一次垃圾回收中的幸存者区（Survivor区）域。来自 Eden 区域和幸存者区（Survivor区）域的存活对象会被复制，即转移到一组新的区域。某个特定对象的目标区域取决于该对象的年龄；年龄足够大的对象会转移到老年代区域（即晋升）；否则，该对象会转移到幸存者区（Survivor区）域，并会被包含在下一次新生代或混合垃圾回收的收集集中。





混合垃圾回收

在并发标记周期成功完成后，G1 垃圾回收器（G1 GC）会从执行新生代垃圾回收切换到执行混合垃圾回收。在混合垃圾回收中，G1 垃圾回收器会选择性地将一些老年代区域添加到即将被回收的 Eden 区和幸存者区（Survivor区）集合中。添加的老年代区域的确切数量由多个标志控制（请参阅“建议”部分中的“驯服混合垃圾回收器”）。在 G1 垃圾回收器回收了足够数量的老年代区域（经过多次混合垃圾回收）后，G1 会恢复执行新生代垃圾回收，直到下一个标记周期完成。

## 标记周期的阶段

标记周期有以下阶段：

- 初始标记阶段：在此阶段，G1 垃圾回收器（G1 GC）标记根对象。此阶段是在正常的（STW）新生代垃圾回收过程中顺带完成的。
- 根区域扫描阶段：G1 垃圾收集器（GC）会扫描在初始标记阶段标记的幸存者区（Survivor区）域，查找指向老年代的引用，并标记被引用的对象。此阶段与应用程序并发运行（非 STW，即非停止世界），并且必须在下一次 STW 新生代垃圾回收开始之前完成。
- 并发标记阶段：G1 垃圾收集器会在整个堆中查找可触及（存活）的对象。此阶段与应用程序并发执行，并且可能会被 STW 新生代垃圾回收中断。
- 标记阶段：此阶段为 STW（Stop The World）收集阶段，有助于完成标记周期。G1 垃圾回收器会清空 SATB（Snapshot At The Beginning）缓冲区，追踪未访问的存活对象，并执行引用处理。
- 清理阶段：在这个最后阶段，G1 垃圾回收器（G1 GC）会执行记账和 RSet 清理的 STW（Stop-The-World）操作。在记账过程中，G1 垃圾回收器会识别出完全空闲的区域和混合垃圾回收候选区域。当清理阶段重置空区域并将其返回到空闲列表时，该阶段部分是并发执行的。



重要默认设置

G1 垃圾回收器（G1 GC）是一种自适应的垃圾回收器，其默认设置使其无需修改即可高效工作。表 10 - 1“G1 垃圾回收器重要选项的默认值”列出了 Java HotSpot 虚拟机（版本构建号 24）中重要选项及其默认值。你可以通过在 JVM 命令行中输入表 10 - 1“G1 垃圾回收器重要选项的默认值”中的选项并更改设置，来根据应用程序的性能需求对 G1 GC 进行调整和优化。



表 10 - 1 G1 垃圾收集器重要选项的默认值

| 选项和默认值                             | 选项                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| `-XX:G1HeapRegionSize=``n`               | 设置 G1 区域的大小。该值必须是 2 的幂，范围从 1 MB 到 32 MB。目标是根据最小 Java 堆大小设置大约 2048 个区域。 |
| `-XX:MaxGCPauseMillis=200`               | 设置期望的最大暂停时间的目标值。默认值为 200 毫秒。指定的值不会根据你的堆大小进行调整。 |
| `-XX:G1NewSizePercent=5`                 | 设置新生代大小的最小堆使用百分比。默认值为 Java 堆的 5%。 Foot1这是一个实验性标志。有关示例，请参阅“如何解锁实验性虚拟机标志”。此设置将替换 `-XX:DefaultMinNewGenPercent` 设置。 |
| `-XX:G1MaxNewSizePercent=60`             | 设置用于新生代大小的堆大小的百分比上限。默认值为 Java 堆大小的 60%。 Footref1这是一个实验性标志。有关示例，请参阅“如何解锁实验性虚拟机标志”。此设置将取代 `-XX:DefaultMaxNewGenPercent` 设置。 |
| `-XX:ParallelGCThreads=``n`              | 设置 STW 工作线程的值。将 `n` 的值设置为逻辑处理器的数量。 `n` 的值在不超过 8 的情况下与逻辑处理器的数量相同。如果逻辑处理器数量超过八个，则将 n 的值设置为逻辑处理器数量的大约 5/8。在大多数情况下，这种设置都可行，但对于较大的 SPARC 系统除外，在这些系统中，n 的值可以设置为逻辑处理器数量的大约 5/16。 |
| `-XX:ConcGCThreads=``n`                  | 设置并行标记线程的数量。将 `n` 设置为并行垃圾回收线程数量（ParallelGCThreads）的大约四分之一。 |
| `-XX:InitiatingHeapOccupancyPercent=45`  | 设置触发标记周期的 Java 堆占用阈值。默认占用率为整个 Java 堆的 45%。 |
| `-XX:G1MixedGCLiveThresholdPercent=85`   | 设置旧区域要被纳入混合垃圾回收周期的占用阈值。默认占用率为 85%。 Footref1这是一个实验性标志。有关示例，请参阅“如何解锁实验性虚拟机标志”。此设置将替换 `-XX:G1OldCSetRegionLiveThresholdPercent` 设置。 |
| `-XX:G1HeapWastePercent=5`               | 设置您愿意浪费的堆内存百分比。当可回收百分比小于堆内存浪费百分比时，Java HotSpot 虚拟机不会启动混合垃圾回收周期。默认值为 5%。 Footref1 |
| `-XX:G1MixedGCCountTarget=8`             | 将标记周期后混合垃圾回收的目标次数设置为收集旧区域，这些旧区域中存活数据最多为 `G1MixedGCLIveThresholdPercent` 。默认值是 8 次混合垃圾回收。混合回收的目标是在这个目标次数范围内。 Footref1 |
| `-XX:G1OldCSetRegionThresholdPercent=10` | 设置在混合垃圾回收周期中要回收的旧区域数量上限。默认值为 Java 堆的 10%。 Footref1 |
| `-XX:G1ReservePercent=10`                | 设置保留的空闲内存百分比，以降低 to-space 溢出的风险。默认值为 10%。当您增加或减少该百分比时，请确保将 Java 堆总量调整相同的幅度。 Footref1 |

Footnote1 此设置在 Java HotSpot VM 23 版及更早版本中不可用。



## 如何解锁实验性虚拟机标志

要更改实验标志的值，您必须先解锁它们。您可以通过在任何实验标志之前在命令行上显式设置 `-XX:+UnlockExperimentalVMOptions` 来实现这一点。例如：

```
java -XX:+UnlockExperimentalVMOptions -XX:G1NewSizePercent=10 -XX:G1MaxNewSizePercent=75 G1test.jar
```



## 建议；推荐；推荐信

在评估和微调 G1 垃圾回收器（G1 GC）时，请牢记以下建议：

- 

- 新生代大小：避免使用 `-Xmn` 选项或任何其他相关选项（如 `-XX:NewRatio` ）显式设置新生代大小。固定新生代大小会覆盖目标暂停时间目标。

- 

  暂停时间目标：当你评估或调优任何垃圾回收时，始终存在延迟与吞吐量的权衡。G1 GC 是一种具有均匀暂停的增量式垃圾回收器，但会给应用程序线程带来更多开销。G1 GC 的吞吐量目标是 90% 的应用程序运行时间和 10% 的垃圾回收时间。将此与 Java HotSpot VM 并行回收器进行比较。并行回收器的吞吐量目标是 99% 的应用程序运行时间和 1% 的垃圾回收时间。因此，当你评估 G1 GC 的吞吐量时，放宽你的暂停时间目标。设定过于激进的目标意味着你愿意承受垃圾回收开销的增加，这会直接影响吞吐量。当你评估 G1 GC 的延迟时，你设定所需的（软）实时目标，G1 GC 将尝试满足该目标。作为副作用，吞吐量可能会受到影响。有关更多信息，请参阅“G1 垃圾回收器中的暂停时间目标”部分。

- 驯服混合垃圾回收：在调优混合垃圾回收时，尝试以下选项。有关这些选项的信息，请参阅“重要默认设置”部分：

  - `-XX:InitiatingHeapOccupancyPercent` ：用于更改标记阈值。
  - `-XX:G1MixedGCLiveThresholdPercent` 和 `-XX:G1HeapWastePercent` ：用于更改混合垃圾回收决策。
  - `-XX:G1MixedGCCountTarget` 和 `-XX:G1OldCSetRegionThresholdPercent` ：用于调整旧区域的 CSet。

## 溢出和耗尽日志消息

当你在日志中看到“to-space overflow”（to 空间溢出）或“to-space exhausted”（to 空间耗尽）消息时，G1 垃圾回收器（G1 GC）没有足够的内存来存放幸存者对象或晋升对象，或者两者都放不下。Java 堆无法再扩展，因为它已经达到了最大容量。示例消息：

- `924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space exhausted), 0.1957310 secs]`
- `924.897: [GC pause (G1 Evacuation Pause) (mixed) (to-space overflow), 0.1957310 secs]`

为缓解该问题，请尝试以下调整：

- 增加 `-XX:G1ReservePercent` 选项的值（并相应地增加总堆大小），以增加 “to-space” 的预留内存量。
- 通过降低 `-XX:InitiatingHeapOccupancyPercent.` 的值来提前启动标记周期
- 增大 `-XX:ConcGCThreads` 选项的值以增加并行标记线程的数量。

有关这些选项的描述，请参阅“重要默认设置”部分。

## 巨型对象和巨型分配

对于 G1 垃圾回收器（GC），任何大小超过半个区域大小的对象都被视为巨型对象。此类对象会直接在老年代的巨型区域中分配。这些巨型区域是一组连续的区域。 `StartsHumongous` 标记连续区域集的起始位置， `ContinuesHumongous` 标记该区域集的延续位置。

在分配任何巨大区域之前，会检查标记阈值，必要时启动并发周期。

在标记周期结束后的清理阶段以及完整的垃圾回收周期中，无用的大型对象会被释放。

为减少复制开销，巨型对象不会包含在任何疏散暂停中。完整的垃圾回收周期会就地压缩巨型对象。

由于每一组 `StartsHumongous` 和 `ContinuesHumongous` 区域仅包含一个巨型对象，因此巨型对象末尾与该对象所跨越的最后一个区域末尾之间的空间未被使用。对于那些仅比堆区域大小的倍数略大的对象，这种未使用的空间可能会导致堆碎片化。

如果您看到由于大量分配而引发了连续的并发周期，并且这些分配正在使您的老年代产生碎片化，那么请增大 `-XX:G1HeapRegionSize` 的值，以使之前的大对象不再被视为大对象，从而遵循常规的分配路径。