#  2 自适应优化（Ergonomics）

自适应优化是指 Java 虚拟机（JVM）和垃圾回收调优（如基于行为的调优）来提高应用程序性能的过程。JVM 为垃圾收集器、堆大小和运行时编译器提供了依赖于平台的默认选项。这些选项能满足不同类型应用程序的需求，同时减少了命令行调优的工作量。此外，基于行为的调优会动态调整堆的大小，以满足应用程序的特定行为需求。

本节介绍这些默认选择和基于行为的调整。在使用后续章节中描述的更详细的控件之前，请先使用这些默认设置。



## 垃圾回收器、堆和运行时编译器的默认选择

一类被称为服务器级别的机器被定义为具备以下特征的机器：

- 2 个或更多物理处理器
- 2GB 或更多的物理内存

在服务器级别的机器上，默认会选择以下内容：

- 吞吐量垃圾回收器
- 初始堆大小为物理内存的 1/64，最大可达 1GB
- 最大堆大小为物理内存的 1/4，最高可达 1GB
-  服务器运行时编译器

有关 64 位系统的初始堆大小和最大堆大小，请参阅《并行收集器》中的“默认堆大小”部分。

服务器级机器的定义适用于除运行某个版本 Windows 操作系统的 32 位平台之外的所有平台。表 2 - 1“默认运行时编译器”展示了为不同平台选择的运行时编译器。



表 2 - 1 默认运行时编译器

| Platform       | Operating System | Default[Foot1](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#BABFAAII) | Default if Server-Class[Footref1](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref7) |
| -------------- | ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| i586           | Linux            | Client                                                       | Server                                                       |
| i586           | Windows          | Client                                                       | Client [Foot2](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref8) |
| SPARC (64-bit) | Solaris          | Server                                                       | Server [Foot3](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#BABIFJCI) |
| AMD (64-bit)   | Linux            | Server                                                       | Server [Footref3](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref9) |
| AMD (64-bit)   | Windows          | Server                                                       | Server [Footref3](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref10) |

Footnote1 “Client” 表示使用客户端运行时编译器。“Server” 表示使用服务器端运行时编译器。

Footnote2 即使在服务器级别的机器上，也选择使用客户端运行时编译器的策略。做出这个选择是因为从历史上看，客户端应用程序（例如交互式应用程序）更常在这种平台和操作系统的组合上运行。

Footnote3 仅支持服务器运行时编译器。

### 基于行为的调优

对于并行收集器，Java SE 提供了两个基于实现应用程序指定行为的垃圾回收调优参数：最大暂停时间目标和应用程序吞吐量目标；请参阅“并行收集器”部分。（这两个选项在其他收集器中不可用。）请注意，这些行为并非总能实现。应用程序需要一个足够大的堆，至少能够容纳所有存活数据。此外，最小堆大小可能会妨碍实现这些期望的目标。

### 最大暂停时间目标

暂停时间是指垃圾回收器停止应用程序并回收不再使用的空间所持续的时长。最大暂停时间目标的目的是限制这些暂停中最长的一次。垃圾回收器会维护暂停的平均时间以及该平均值的方差。该平均值从执行开始时算起，但会进行加权处理，使得最近的暂停具有更高的权重。如果暂停时间的平均值加上方差大于最大暂停时间目标，那么垃圾回收器会认为未达到该目标。

最大停顿时间目标通过命令行选项 `-XX:MaxGCPauseMillis=<nnn>` 指定。这被视为向垃圾回收器发出的一个提示，表明期望的停顿时间为 `<nnn>` 毫秒或更短。垃圾回收器将调整 Java 堆大小和其他与垃圾回收相关的参数，试图使垃圾回收停顿时间短于 `<nnn>` 毫秒。默认情况下，没有最大停顿时间目标。这些调整可能会导致垃圾回收更频繁地发生，从而降低应用程序的整体吞吐量。垃圾回收器会在满足吞吐量目标之前尝试满足任何停顿时间目标。不过，在某些情况下，无法达到期望的停顿时间目标。

### 吞吐量目标

吞吐量目标是根据收集垃圾所花费的时间以及垃圾收集之外所花费的时间（称为应用程序时间）来衡量的。该目标由命令行选项 `-XX:GCTimeRatio=<nnn>` 指定。垃圾收集时间与应用程序时间的比率为 `1 / (1 + <nnn> )`。例如， `-XX:GCTimeRatio=19` 将垃圾收集的总时间目标设定为 1/20，即 5%。

垃圾回收所花费的时间是新生代和老年代回收的总时间之和。如果未达到吞吐量目标，则会增加各代的大小，以延长应用程序在两次回收之间的运行时间。

###  内存占用目标(Footprint Goal)

如果吞吐量和最大暂停时间目标都已达成，那么垃圾回收器会缩小堆的大小，直到其中一个目标（通常是吞吐量目标）无法达成。然后再处理未达成的目标。

##  调优策略

除非你确定需要一个大于默认最大堆大小的堆，否则不要为堆选择一个最大值。为你的应用程序选择一个足够的吞吐量目标。

堆将增长或收缩到一个能支持所选吞吐量目标的大小。应用程序行为的变化可能会导致堆增长或收缩。例如，如果应用程序开始以更高的速率进行内存分配，堆将增长以维持相同的吞吐量。

如果堆增长到其最大大小且仍未达到吞吐量目标，则说明对于该吞吐量目标而言，最大堆大小设置得太小。将最大堆大小设置为接近平台总物理内存但又不会导致应用程序发生交换的值。再次执行应用程序。如果仍然未达到吞吐量目标，则说明对于平台上的可用内存而言，应用程序时间目标设置得过高。

如果可以达到吞吐量目标，但存在过长的停顿，那么选择一个最大停顿时间目标。选择最大停顿时间目标可能意味着无法达到吞吐量目标，因此要选择对应用程序来说可接受的折衷值。

通常情况下，随着垃圾回收器试图达成相互冲突的目标，堆的大小会出现波动。即使应用程序已进入稳定状态，情况也是如此。实现吞吐量目标的压力（这可能需要更大的堆）与实现最大暂停时间和最小内存占用目标（这两者可能都需要较小的堆）相互冲突。