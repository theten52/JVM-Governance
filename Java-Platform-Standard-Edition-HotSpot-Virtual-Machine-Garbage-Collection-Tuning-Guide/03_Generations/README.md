# 3 分代（Generations）

Java SE 平台的一个优势在于，它能让开发者免受内存分配和垃圾回收复杂性的困扰。然而，当垃圾回收成为主要瓶颈时，了解这一隐藏实现的某些方面会很有帮助。垃圾回收器会对应用程序使用对象的方式做出假设，这些假设体现在可调整的参数中，通过调整这些参数可以在不牺牲抽象能力的前提下提升性能。

当运行程序中的任何指针都无法再访问某个对象时，该对象就被视为垃圾。最直接的垃圾回收算法会遍历每个可访问的对象。剩余的任何对象都被视为垃圾。这种方法所需的时间与存活对象的数量成正比，对于维护大量实时数据的大型应用程序来说，这是难以接受的。

虚拟机集成了多种不同的垃圾回收算法，这些算法通过分代收集的方式组合使用。简单的垃圾回收会检查堆中的每个存活对象，而分代收集则利用大多数应用程序在经验上观察到的一些特性，来尽量减少回收未使用（垃圾）对象所需的工作量。这些观察到的特性中最重要的是弱分代假说，该假说指出大多数对象的存活时间都很短。

图 3 - 1“对象生命周期的典型分布”中的蓝色区域是对象生命周期的典型分布。x 轴表示以已分配字节数衡量的对象生命周期。y 轴上的字节数是具有相应生命周期的对象中的总字节数。左侧的尖锐峰值代表那些在分配后不久就可以被回收（换句话说，“死亡”）的对象。例如，迭代器对象通常只在单个循环的持续时间内存在。

***图 3 - 1 对象生命周期的典型分布\***

![Description of Figure 3-1 follows](./assets/README/jsgct_dt_003_alc_vs_srvng.png)

[“图 3 - 1 对象生命周期的典型分布”说明](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img_text/jsgct_dt_003_alc_vs_srvng.html)

*此图表的 x 轴“已分配字节数”表示以已分配字节数衡量的对象生命周期。y 轴“存活字节数”是具有相应生命周期的对象上的总字节数。图表的左三分之一标记为“次要收集”。图表的右三分之二标记为“主要收集”。绘制线下方的区域为实心蓝色。该区域代表对象生命周期的典型分布。该区域在左侧急剧达到峰值，并向右延伸。图表在其周围的文本中有进一步描述。*

有些对象的存活时间确实更长，因此分布会向右延伸。例如，通常会有一些在初始化时分配的对象，它们会一直存活到进程退出。在这两个极端之间，是那些在某些中间计算期间存活的对象，在这里表现为初始峰值右侧的凸起部分。有些应用程序的分布看起来非常不同，但令人惊讶的是，有相当多的应用程序具有这种大致的形状。通过关注大多数对象“早亡”这一事实，就可以实现高效的垃圾回收。

为针对这种情况进行优化，内存按代进行管理（内存池存放不同生命周期的对象）。当某一代的内存池填满时，就会在该代中进行垃圾回收。绝大多数对象会被分配到专门用于存放年轻对象的内存池（新生代）中，而且大多数对象会在那里“消亡”。当新生代填满时，会触发一次次要回收（Minor GC），此时仅回收新生代中的垃圾，其他代中的垃圾不会被回收。假设弱分代假说成立，即新生代中的大多数对象都是垃圾且可以被回收，那么次要回收（Minor GC）就可以得到优化。从一阶近似来看，这种回收的成本与被回收的存活对象数量成正比；一个充满死亡对象的新生代可以被非常快速地回收。通常，在每次次要回收（Minor GC）过程中，新生代中存活对象的一部分会被移动到老年代。最终，老年代会被填满，必须进行回收，从而触发一次主要回收（Major GC），此时会回收整个堆中的垃圾。 主要垃圾回收（Major GC）通常比次要垃圾回收（Minor GC）持续的时间长得多，因为涉及的对象数量要多得多。

如“自适应优化（Ergonomics）”部分所述，自适应优化机制会动态选择垃圾收集器，以便在各种应用程序上都能提供良好的性能。串行垃圾收集器是为处理小数据集的应用程序设计的，其默认参数经过选择，对大多数小型应用程序都很有效。并行或吞吐量垃圾收集器则适用于处理中大型数据集的应用程序。自适应优化机制选择的堆大小参数以及自适应大小策略的特性旨在为服务器应用程序提供良好的性能。这些选择在大多数（但并非所有）情况下都能很好地工作，这也引出了本文档的核心原则：

 **注意：**如果垃圾回收成为瓶颈，你很可能需要自定义总堆大小以及各代的大小。查看详细的垃圾回收器输出，然后探究你的各项性能指标对垃圾回收器参数的敏感度。

图 3 - 2“除并行收集器和 G1 之外的各代默认布局”展示了各代的默认布局（适用于除并行收集器和 G1 之外的所有收集器）：

***图 3 - 2 各代的默认排列方式（并行收集器和 G1 除外）\***

![Description of Figure 3-2 follows](./assets/README/jsgct_dt_001_armgnt_gn.png)

[“图 3 - 2 各代的默认排列方式（并行收集器和 G1 除外）”的说明](https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/img_text/jsgct_dt_001_armgnt_gn.html)

*该图由一行六个矩形组成。这些矩形的标注如下（从左到右）：*

1. *Eden*
2. *Survivor*
3. *Spaces*
4. *Virtual*
5. *No label*
6. *Virtual*

*矩形 1 至 4 标注为“新生代”。矩形 5 至 6 标注为“老年代”。*

在初始化时，会虚拟地保留一个最大地址空间，但除非需要，否则不会将其分配给物理内存。为对象内存保留的完整地址空间可以划分为新生代和老年代。

新生代由 Eden 区和两个幸存者空间（Survivor区）组成。大多数对象最初是在 Eden 区分配的。任何时候，其中一个幸存者空间（Survivor区）都是空的，它作为 Eden 区中所有存活对象的目标空间；另一个幸存者空间（Survivor区）则是下一次复制收集时的目标空间。对象以这种方式在幸存者空间（Survivor区）之间复制，直到它们足够“老”，可以晋升（复制到老年代）。

## 性能考量

垃圾回收性能主要有两个衡量指标：

- 吞吐量是指在较长时间段内，未用于垃圾回收的总时间所占的百分比。吞吐量包括分配内存所花费的时间（但通常不需要针对内存分配速度进行调优）。
- 暂停是指由于正在进行垃圾回收，应用程序看起来无响应的时间段。

用户对垃圾回收有不同的要求。例如，一些人认为衡量 Web 服务器的正确指标是吞吐量，因为垃圾回收期间的暂停可能是可以容忍的，或者仅仅被网络延迟所掩盖。然而，在交互式图形程序中，即使是短暂的暂停也可能对用户体验产生负面影响。

一些用户对其他因素较为敏感。内存占用（Footprint）是一个进程的工作集，以页面和缓存行为单位进行衡量。在物理内存有限或进程众多的系统中，内存占用（Footprint）可能会决定可扩展性。及时性（Promptness）是指对象变为无效到内存可用之间的时间，这对于包括远程方法调用（RMI）在内的分布式系统来说是一个重要的考量因素。

一般来说，为特定的代选择大小是在这些因素之间进行权衡。例如，一个非常大的新生代可能会使吞吐量最大化，但这是以占用空间（expense of footprint）、及时性和暂停时间为代价的。可以通过使用较小的新生代来最小化新生代的暂停时间，但这会牺牲吞吐量。一个代的大小设置不会影响另一个代的收集频率和暂停时间。

选择代（generation）的大小并没有唯一正确的方法。最佳选择取决于应用程序使用内存的方式以及用户需求。因此，虚拟机对垃圾回收器的选择并不总是最优的，并且可以使用“调整代的大小”一节中描述的命令行选项来覆盖该选择。

##  度量

吞吐量和占用空间（footprint）最好使用特定于应用程序的指标来衡量。例如，Web 服务器的吞吐量可以使用客户端负载生成器进行测试，而服务器的占用空间可以在 Solaris 操作系统上使用 `pmap` 命令进行测量。然而，由于垃圾回收导致的暂停可以通过检查虚拟机本身的诊断输出来轻松估算。

命令行选项 `-verbose:gc` 会使每次垃圾回收时打印有关堆和垃圾回收的信息。例如，以下是一个大型服务器应用程序的输出：

```
[GC 325407K->83000K(776768K), 0.2300771 secs]
[GC 325816K->83372K(776768K), 0.2454258 secs]
[Full GC 267628K->83769K(776768K), 1.8479984 secs]
```

输出显示了两次次要垃圾回收（Minor GC），随后是一次主要垃圾回收（Major GC）。箭头前后的数字（例如，第一行中的 `325407K->83000K` ）分别表示垃圾回收前后存活对象的总大小。次要垃圾回收（Minor GC）之后，该大小包含了一些已成为垃圾（不再存活）但无法被回收的对象。这些对象要么位于老年代中，要么被老年代中的对象引用。

括号中的下一个数字（例如，再次参考第一行的 `(776768K)` ）是堆的已提交大小：即在不向操作系统请求更多内存的情况下，可用于存储 Java 对象的空间量。请注意，此数字仅包含一个幸存者空间（Survivor区）。除了在垃圾回收期间，在任何给定时间只会使用一个幸存者空间（Survivor区）来存储对象。

该行的最后一项（例如， `0.2300771 secs` ）表示执行收集操作所花费的时间，在这种情况下大约为四分之一秒。

第三行中Major GC的格式类似。

 **注意：**`-verbose:gc` 生成的输出格式在未来版本中可能会发生变化。

命令行选项 `-XX:+PrintGCDetails` 会使系统打印出有关集合的额外信息。这里展示了使用串行垃圾回收器时带有 `-XX:+PrintGCDetails` 的输出示例。

```
[GC [DefNew: 64575K->959K(64576K), 0.0457646 secs] 196016K->133633K(261184K), 0.0459067 secs]
```

这表明次要收集（Minor GC）回收了约 98% 的新生代对象， `DefNew: 64575K->959K(64576K)` ，耗时 `0.0457646 secs` （约 45 毫秒）。

整个堆的使用率降至约 51%（ `196016K->133633K(261184K)` ），如最终时间 `0.0459067 secs` 所示，此次收集（除新生代收集之外）还有一些轻微的额外开销。

 **注意：**`-XX:+PrintGCDetails` 生成的输出格式在未来版本中可能会发生变化。

选项 `-XX:+PrintGCTimeStamps` 会在每次垃圾回收开始时添加一个时间戳。这有助于查看垃圾回收的发生频率。

```
111.042: [GC 111.042: 
	[DefNew: 8128K->8128K(8128K), 0.0000505 secs]//新生代GC
	111.042: [Tenured: 18154K->2311K(24576K), 0.1290354 secs] //老年代GC
	26282K->2311K(32704K), 0.1293306 secs //总内存和总耗时
]
```

该收集操作在应用程序执行约 111 秒后开始。次要收集（Minor GC）操作大约在同一时间开始。此外，还显示了由“老年代（Tenured）”界定的主要收集（Major GC）操作的信息。老年代的使用率降至约 10%（ `18154K->2311K(24576K)` ），耗时 `0.1290354 secs` （约 130 毫秒）。